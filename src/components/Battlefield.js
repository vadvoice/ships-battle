import { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import {
  COLOR_SCHEMA,
  GAME_STAGES,
  ROW_NAMES,
  CELL_WIDTH,
  CELL_HEIGHT,
  ROWS_AMOUNT,
  COLUMNS_AMOUNT,
  SHIP_DETAILS,
} from '@/libs/config';
import { getAffectedCells, getCoords } from '@/libs/helpers';
import BattlefieldSettings from './BattlefieldSettings';

const initialBattlefieldSetup = {
  shipDetails: SHIP_DETAILS,
  currentShipIndex: 0,
  currentShip: SHIP_DETAILS[0],
  horizontalPlacement: true,
  fleet: [],
  stage: GAME_STAGES.planning,
};

export default function Battlefield({
  actions: { onChange },
  gameSetup,
  position,
  autoGenerated = false,
}) {
  const [battlefield, setBattlefield] = useState(initialBattlefieldSetup);
  const battlefieldTable = useRef();
  const isMenuState = battlefield.stage === GAME_STAGES.menu;
  const isPlanningStage = battlefield.stage === GAME_STAGES.planning;
  const isGamePlanningComplete =
    battlefield.stage === GAME_STAGES.planningComplete;
  const isGameStarted = battlefield.stage === GAME_STAGES.ongoing;

  const currentHighlightedCells = useMemo(() => [], []);
  const resetBattleFieldOngoingProcess = useCallback(() => {
    currentHighlightedCells.length = 0;
    const cells = battlefieldTable.current.querySelectorAll('td');
    cells.forEach((el) => el.classList.remove(COLOR_SCHEMA.hover));
  }, [currentHighlightedCells]);

  const handleBattlefieldClick = useCallback(
    (e) => {
      if (!isPlanningStage) {
        return;
      }
      if (e.target.tagName !== 'TD') {
        return;
      }

      const affectedCells =
        getAffectedCells(e.target, battlefieldTable, battlefield) || [];
      const isOverlapsWithExistingShips = battlefield.fleet.some(
        ({ position }) => {
          return affectedCells.map(getCoords).some((coord) => {
            return position.some((p) => p.raw === coord.raw);
          });
        }
      );

      const isShipFitOnBattlefield =
        battlefield.currentShip.length === affectedCells.length;

      if (isOverlapsWithExistingShips || !isShipFitOnBattlefield) {
        return;
      }

      const nextShipIndex = battlefield.currentShipIndex + 1;
      const isNextShipAvailable = battlefield.shipDetails[nextShipIndex];

      setBattlefield({
        ...battlefield,
        stage: isNextShipAvailable
          ? battlefield.stage
          : GAME_STAGES.planningComplete,
        currentShipIndex: nextShipIndex,
        currentShip: battlefield.shipDetails[nextShipIndex],
        fleet: [
          ...battlefield.fleet,
          {
            name: battlefield.currentShip.name,
            position: currentHighlightedCells.map(getCoords),
          },
        ],
      });
    },
    [battlefield, currentHighlightedCells, isPlanningStage]
  );

  const hightlightShipOnBattlefield = (target) => {
    if (!target || !isPlanningStage) return;
    resetBattleFieldOngoingProcess();

    (getAffectedCells(target, battlefieldTable, battlefield) || []).map((el) =>
      currentHighlightedCells.push(el)
    );

    currentHighlightedCells.map((el) => {
      el.classList.add(COLOR_SCHEMA.hover);
    });
  };

  const onMouseEnterBattlefield = (e) => {
    if (e.target.tagName !== 'TD') {
      return;
    }
    hightlightShipOnBattlefield(e.target);
  };

  const resetFleet = () => {
    setBattlefield(initialBattlefieldSetup);
    const cells = battlefieldTable.current.querySelectorAll('td');
    cells.forEach((el) => {
      COLOR_SCHEMA.placed.split(' ').forEach((className) => {
        el.classList.remove(className);
      });
      // TODO: old way to remove multiple classes
      // el.classList.remove(COLOR_SCHEMA.placed)
    });
  };

  const onGameStart = () => {
    setBattlefield({
      ...battlefield,
      stage: GAME_STAGES.ongoing,
    });

    onChange({ ...gameSetup, [`player${position}`]: battlefield });
  };

  const genericFleet = useCallback(async () => {
    function getRandomBetween(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    let cell;
    while (!cell && battlefield.currentShip) {
      const columnIndex = getRandomBetween(1, COLUMNS_AMOUNT);
      const rowIndex = getRandomBetween(1, ROWS_AMOUNT - 1);
      cell = battlefieldTable.current.querySelector(
        `td[data-index="${columnIndex}"][data-row="${rowIndex}"]`
      );

      if (!cell) {
        break;
      }

      const affectedCells =
        getAffectedCells(cell, battlefieldTable, battlefield) || [];
      const isOverlapsWithExistingShips = battlefield.fleet.some(
        ({ position }) => {
          return affectedCells.map(getCoords).some((coord) => {
            return position.some((p) => p.raw === coord.raw);
          });
        }
      );

      const isShipFitOnBattlefield =
        battlefield.currentShip.length === affectedCells.length;

      if (isOverlapsWithExistingShips || !isShipFitOnBattlefield) {
        cell = null;
        break;
      }

      const event = new MouseEvent('mousemove', {
        view: window,
        bubbles: true,
        cancelable: true,
      });
      cell.dispatchEvent(event);

      handleBattlefieldClick({ target: cell });
    }
  }, [handleBattlefieldClick, battlefield]);

  const autoGenerate = () => {
    resetFleet();
    genericFleet();
  };

  const onPositionChange = () => {
    setBattlefield({
      ...battlefield,
      horizontalPlacement: !battlefield.horizontalPlacement,
    });
  };

  // EFFECTS
  useEffect(() => {
    if (!autoGenerated) {
      return;
    }
    genericFleet();
  }, [battlefield.fleet, autoGenerated, genericFleet]);

  useEffect(() => {
    if (!battlefield.fleet.length) {
      return;
    }

    battlefield.fleet.map((el) => {
      el.position.map((ship) => {
        if (!ship.ref.classList.contains(COLOR_SCHEMA.placed)) {
          COLOR_SCHEMA.placed.split(' ').forEach((className) => {
            ship.ref.classList.add(className);
          });
          // TODO: ald way to add multiple classes
          // ship.ref.classList.add(COLOR_SCHEMA.placed);
        }
      });
    });
    resetBattleFieldOngoingProcess();
  }, [battlefield.fleet, resetBattleFieldOngoingProcess]);

  if (isMenuState) {
    return <></>;
  }

  return (
    <div>
      <h4 className="text-2xl font-bold dark:text-white text-center my-2">
        {autoGenerated ? 'PC' : 'Player'}
      </h4>

      <table
        ref={battlefieldTable}
        // className={`m-0 border-spacing-0.5 border-separate ${COLOR_SCHEMA.empty}`}
        className={`m-0 border-spacing-0.5 border-separate`}
        onClick={handleBattlefieldClick}
        onMouseMove={onMouseEnterBattlefield}
      >
        <thead>
          <tr>
            {Array(ROWS_AMOUNT)
              .fill()
              .map((_, headIndex) => {
                return (
                  <th
                    // className={`${CELL_WIDTH} ${CELL_HEIGHT} uppercase`}
                    className={`w-10 h-10 uppercase`}
                    key={`table-head-${headIndex}`}
                  >
                    {headIndex || ''}
                  </th>
                );
              })}
          </tr>
        </thead>
        <tbody>
          {Array(COLUMNS_AMOUNT)
            .fill()
            .map((el, index) => {
              return (
                <tr key={`row-${index}`}>
                  {Array(8)
                    .fill()
                    .map((el, innerIndex) => {
                      if (!innerIndex) {
                        return (
                          <th
                            key={`table-data-${innerIndex}`}
                            className={`${CELL_WIDTH} ${CELL_HEIGHT} uppercase`}
                          >
                            {ROW_NAMES[index]}
                          </th>
                        );
                      }
                      return (
                        <td
                          key={`table-data-${innerIndex}`}
                          className={`${CELL_WIDTH} ${CELL_HEIGHT} text-center border-solid border-2 border-indigo-600 rounded relative hover:bg-sky-700 cursor-pointer`}
                          data-index={innerIndex}
                          data-row={index + 1}
                        >
                          {/* {innerIndex} */}
                        </td>
                      );
                    })}
                </tr>
              );
            })}
        </tbody>
      </table>

      {isGameStarted ? null : (
        <BattlefieldSettings
          gameSetup={battlefield}
          actions={{
            onReset: resetFleet,
            autoGenerate,
            onPositionChange,
            onReady: () => {
              onGameStart();
            },
          }}
        />
      )}
    </div>
  );
}
