import { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import {
  COLOR_SCHEMA,
  GAME_STAGES,
  ROW_NAMES,
  CELL_WIDTH,
  CELL_HEIGHT,
  ROWS_AMOUNT,
  COLUMNS_AMOUNT,
  SHIP_DETAILS,
} from '@/libs/config';
import { getAffectedCells, getCoords } from '@/libs/helpers';
import BattlefieldSettings from './BattlefieldSettings';

export default function Battlefield({
  actions: { onChange },
  gameSetup,
  autoGenerated = false,
}) {
  const initialBattlefieldSetup = {
    shipDetails: SHIP_DETAILS,
    currentShipIndex: 1,
    currentShip: SHIP_DETAILS[1],
    horizontalPlacement: true,
    fleet: [],
    stage: GAME_STAGES.planning,
  };
  const [battlefield, setBattlefield] = useState(initialBattlefieldSetup);
  // const fleetSide = autoGenerated ? 'enemyFleet' : 'fleet';
  const battlefieldTable = useRef();
  const isMenuState = battlefield.stage === GAME_STAGES.menu;
  const isGamePlanningComplete =
    battlefield.stage === GAME_STAGES.planningComplete;
  const isGameStarted = battlefield.stage === GAME_STAGES.ongoing;

  const currentHighlightedCells = useMemo(() => [], []);
  const resetBattleFieldOngoingProcess = useCallback(() => {
    // currentHighlightedCells.map((el) => {
    //   el.classList.remove(COLOR_SCHEMA.hover);
    // });
    currentHighlightedCells.length = 0;
    const cells = battlefieldTable.current.querySelectorAll('td');
    cells.forEach((el) => el.classList.remove(COLOR_SCHEMA.hover));
  }, [currentHighlightedCells]);

  const handleBattlefieldClick = useCallback(
    (e) => {
      if (isGamePlanningComplete) {
        return;
      }
      if (e.target.tagName !== 'TD') {
        return;
      }

      const affectedCells = getAffectedCells(e.target, battlefieldTable, battlefield) || [];
      const isOverlapsWithExistingShips = battlefield.fleet.some(
        ({ position }) => {
          return affectedCells.map(getCoords).some((coord) => {
            return position.some((p) => p.raw === coord.raw);
          });
        }
      );

      const isShipFitOnBattlefield =
        battlefield.currentShip.length === affectedCells.length;

      if (isOverlapsWithExistingShips || !isShipFitOnBattlefield) {
        return;
      }

      const nextShipIndex = battlefield.currentShipIndex + 1;
      const isNextShipAvailable = battlefield.shipDetails[nextShipIndex];

      setBattlefield({
        ...battlefield,
        stage: isNextShipAvailable
          ? battlefield.stage
          : GAME_STAGES.planningComplete,
        currentShipIndex: nextShipIndex,
        currentShip: battlefield.shipDetails[nextShipIndex],
        fleet: [
          ...battlefield.fleet,
          {
            name: battlefield.currentShip.name,
            position: currentHighlightedCells.map(getCoords),
          },
        ],
      });
    },
    [
      battlefield,
      currentHighlightedCells,
      isGamePlanningComplete,
      setBattlefield,
    ]
  );

  const hightlightShipOnBattlefield = (target) => {
    if (!target || isGamePlanningComplete) return;
    resetBattleFieldOngoingProcess();

    (getAffectedCells(target, battlefieldTable, battlefield) || []).map((el) =>
      currentHighlightedCells.push(el)
    );

    currentHighlightedCells.map((el) => {
      el.classList.add(COLOR_SCHEMA.hover);
    });
  };

  const onMouseEnterBattlefield = (e) => {
    if (e.target.tagName !== 'TD') {
      return;
    }
    hightlightShipOnBattlefield(e.target);
  };

  const resetFleet = () => {
    setBattlefield(initialBattlefieldSetup);
    const cells = battlefieldTable.current.querySelectorAll('td');
    cells.forEach((el) => el.classList.remove(COLOR_SCHEMA.placed));
  };

  const genericFleet = useCallback(async () => {
    function getRandomBetween(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    let counter = 1;

    while (counter < battlefield.shipDetails.length) {
      const index = getRandomBetween(0, COLUMNS_AMOUNT - 1);
      const targetCellRow = getRandomBetween(0, ROWS_AMOUNT - 1);
      const cell = battlefieldTable.current.querySelector(
        `td[data-index="${index}"][data-row="${targetCellRow}"]`
      );

      if (cell) {
        const event = new MouseEvent('mousemove', {
          view: window,
          bubbles: true,
          cancelable: true,
        });
        cell.dispatchEvent(event);

        handleBattlefieldClick({ target: cell });
        counter += 1;
      }
    }
  }, [battlefield.shipDetails.length, handleBattlefieldClick]);

  const autoGenerate = () => {
    resetFleet();
    genericFleet();
  };

  const onPositionChange = () => {
    setBattlefield({
      ...battlefield,
      horizontalPlacement: !battlefield.horizontalPlacement,
    });
  };

  // EFFECTS
  useEffect(() => {
    if (autoGenerated) {
      genericFleet();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoGenerated]);

  useEffect(() => {
    if (!battlefield.fleet.length) {
      return;
    }

    battlefield.fleet.map((el) => {
      el.position.map((ship) => {
        if (!ship.ref.classList.contains(COLOR_SCHEMA.placed)) {
          ship.ref.classList.add(COLOR_SCHEMA.placed);
        }
      });
    });
    resetBattleFieldOngoingProcess();
  }, [battlefield.fleet, resetBattleFieldOngoingProcess]);

  if (isMenuState) {
    return <></>;
  }

  return (
    <div>
      <h4 className="text-2xl font-bold dark:text-white text-center my-2">
        {autoGenerated ? 'PC' : 'Player'}
      </h4>

      <table
        ref={battlefieldTable}
        // className={`m-0 border-spacing-0.5 border-separate ${COLOR_SCHEMA.empty}`}
        className={`m-0 border-spacing-0.5 border-separate`}
        onClick={handleBattlefieldClick}
        onMouseMove={onMouseEnterBattlefield}
      >
        <thead>
          <tr>
            {Array(ROWS_AMOUNT)
              .fill()
              .map((_, headIndex) => {
                return (
                  <th
                    // className={`${CELL_WIDTH} ${CELL_HEIGHT} uppercase`}
                    className={`w-10 h-10 uppercase`}
                    key={`table-head-${headIndex}`}
                  >
                    {headIndex || ''}
                  </th>
                );
              })}
          </tr>
        </thead>
        <tbody>
          {Array(COLUMNS_AMOUNT)
            .fill()
            .map((el, index) => {
              return (
                <tr key={`row-${index}`}>
                  {Array(8)
                    .fill()
                    .map((el, innerIndex) => {
                      if (!innerIndex) {
                        return (
                          <th
                            key={`table-data-${innerIndex}`}
                            className={`${CELL_WIDTH} ${CELL_HEIGHT} uppercase`}
                          >
                            {ROW_NAMES[index]}
                          </th>
                        );
                      }
                      return (
                        <td
                          key={`table-data-${innerIndex}`}
                          className={`${CELL_WIDTH} ${CELL_HEIGHT} text-center border-solid border-2 border-indigo-600 rounded relative hover:bg-sky-700 cursor-pointer`}
                          data-index={innerIndex}
                          data-row={index}
                        >
                          {/* {innerIndex} */}
                        </td>
                      );
                    })}
                </tr>
              );
            })}
        </tbody>
      </table>

      <BattlefieldSettings
        gameSetup={battlefield}
        actions={{
          onReset: resetFleet,
          autoGenerate,
          onPositionChange,
          onReady: () => {
            // TODO: !game stage
            console.log('ready!');
          },
        }}
      />
    </div>
  );
}
